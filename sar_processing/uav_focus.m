% uav_focus.m
clear variables
close all;
clc;

%% Add the paths
% Add the folders with the functions

addpath('./trajectories',...
    './sar_utilities',...
    './focusing', ...
    genpath('../utilities'),...
    addpath(genpath('../range_compression')));

%% Definition of the parameters

% Each experiment has a folder. The folder can be generated using the
% generateProjectFolder.m script.
%
% The folder will containg the following sub-directories:

% raw:          place here the .dat file generated by the SDR
% rc:           the script will write in this folder the range compressed data
% images:       place here images, videos or figures of the experiment
% trajectories: place here the .mat file containing the
%               trajectory of the platform for the current experiment. See the
%               loadTrajectories.m function
% waveform:     Place here the .mat file containing the transmitted waveform

% TODO: write a file info.txt with infos about the experiment such as (PRF, PRI,
% pulse length, bandwidth, central frequency, total trajectory lenth)

% Folder of the experiment.
exp_name = "exp1_old";%"exp5_mono";
radar_mode = "bistatic";
experiment_folder              = "D:\20220826_bistatic\exp1";
%experiment_folder              = strcat("D:\20230713_bistatic\",exp_name);
% experiment_folder              = strcat("D:\20230616_monostatic\exp5");

% Maximum range. The script will cut the data after range compression
max_range                      = 2000;

% Over sampling factor. After range compression and data cut, the data will be
% oversampled by this factor in fast time
OSF                            = 4;

% Under sampling factor for the slow-times (odd-number!). We use a very
% high PRF, therefore we can filter the data in slow-time and undersample
% it to improve SNR and reduce computational burden in the TDBP
USF                            = 7;

% Flag for the notching of the zero doppler peak (mean removal). The direct
% path from TX to RX antennae will be very strong. This flag abilitate a
% zero-doppler filtering of the data in slow-time.
zero_doppler_notch             = 0;



% Starting sample to process in slow-time. This is useful to trow away some
% samples at the beginning of the acquisition
index_start = 1;


%% Start the processing

% loading the parameters of the radar (f0,PRI,PRF,BW,fs,gains, waveform, etc.)
radar_parameters = loadRadarParameters(experiment_folder,radar_mode);

% Convert raw data from .dat to .mat
rawDataConvert(experiment_folder, radar_parameters.samples_waveform);

% load the raw data and range compress it. If it finds some data in the RC
% folder it just loads it without doing the range compression.
[Drc, t_ax, tau_ax] = loadRawDataAndRangeCompress(experiment_folder, radar_parameters, max_range, OSF);

figure; imagesc(tau_ax, t_ax*3e8/2, db(Drc)); colorbar; title("Range compressed data without zero doppler notching");
xlabel("slow time [s]"); ylabel("fast time [s]"); axis xy, colormap jet

% Cut the data to remove bad values at the beginning of the acquisition
Drc = Drc(:,index_start:end);
tau_ax = tau_ax(index_start:end);
%% Bistatic processing
[POSE, lla0, targets] = loadDroneTrajectory(experiment_folder);
[tx_enu, rx_enu,yaw] = alignDroneRadarTime(POSE, targets, tau_ax, radar_parameters);

if strcmp(radar_parameters.mode, "bistatic")
    Drc_corr = correctTimeShift(Drc, tx_enu, rx_enu, t_ax);
    Drc_corr = correctFreqShift(Drc_corr,tx_enu, rx_enu, radar_parameters.f0);
    Drc = Drc_corr; clear Drc_corr;
else
    antDist = sqrt(sum((tx_enu(1,:) - rx_enu(1,:)).^2));
    t_ax = t_ax + antDist / physconst("LightSpeed");
end
%% Nothc filtering
if zero_doppler_notch
    % Notch filter on the zero Doppler to kill the direct path from TX antenna
    % to RX antenna
    Drc = zeroDopplerNotch(Drc, radar_parameters.PRF);

    index_zero = find(min(abs(t_ax))==t_ax);

    % Plot the range compressed data matrix
    figure; imagesc(tau_ax, t_ax(index_zero:end), db(Drc(index_zero:end,:)));
    axis xy
    xlabel("Slow time [s]");
    ylabel("range [m]");
    title("Range compressed data WITH zero doppler notching");
    colorbar;
    clim([100,140]);

    showDopplerPlot(Drc,tau_ax, t_ax, "full"); clim([140,200])
    % Drc_ll = conv2(Drc, fir1(501,12/radar_parameters.PRF), "same");
    % showDopplerPlot(Drc_ll(1:end,:),tau_ax, t_ax(1:end), "full"); clim([140,200])

end

% Low pass filter and undersample the range compressed data. We have a very
% high PRF, so we can do it
[Drc_lp, radar_parameters_lp, tau_ax_lp] = lowPassFilterAndUndersample(Drc, radar_parameters, tau_ax, USF);
% Filter the range compressed data with a gaussian filter in range to
% remove sidelobes
% Drc_lp = filterRange(Drc, t_ax, radar_parameters.B);
showDopplerPlot(Drc_lp,tau_ax_lp, t_ax, "full");
% caxis([140, 200])
%
figure; imagesc(tau_ax_lp, t_ax*3e8/2, db(Drc_lp));
axis xy
xlabel("Slow time [s]");
ylabel("range [m]");
title(["Range compressed data with range filtering for sidelobes removal"]);
colormap jet
Drc = Drc_lp;
tau_ax = tau_ax_lp;
rx_enu = rx_enu(1:USF:end,:);
tx_enu = tx_enu(1:USF:end,:);
yaw = yaw(1:USF:end);
%%
% Plot the incoherent mean along slow-times to check resolution from the
% direct path.
figure; plot(t_ax*3e8/2, mean(abs(Drc),2)); xlabel("range [m]"); ylabel("Amplitude");
title("Resolution check from the direct path"); grid on;
%% Coordinate transformation
% define the rotation matrix to use SCH reference frame. It is like XYZ,
% where S move along the aperture
[enu2sch, center_enu] = computeENU2SCH(rx_enu);

rx_sch = (rx_enu - center_enu) * enu2sch;
tx_sch = (tx_enu - center_enu) * enu2sch;

rx_speed = [0;diff(rx_sch(:,1))] ./ (tau_ax(2)-tau_ax(1));


figure,subplot(4,1,1),plot(rx_sch(:,1)),title("S"),grid
subplot(4,1,2),plot(rx_sch(:,2)), title("C"),grid
subplot(4,1,3),plot(rx_sch(:,3)), title("H"),grid
subplot(4,1,4),plot(yaw), title("Yaw"),grid

for n = 1:length(targets)
    tgt_sch(n,:) = ([targets(n).X targets(n).Y targets(n).Z] - center_enu) * enu2sch;
end


% Scenario ENU
figure, plot(rx_enu(:,1),rx_enu(:,2),"LineWidth",1.7), title("Scenario ENU"), hold on
plot(rx_enu(1,1),rx_enu(1,2),'ro')
for n = 1:length(targets)
    plot(targets(n).X,targets(n).Y,'^r',LineWidth=1)
end
%TX
plot(tx_enu(1,1),tx_enu(1,2),'*g',LineWidth=1)
%plot(targets(5).X,targets(5).Y,'^k',LineWidth=1)
hold off
axis equal

% Scenario SCH
figure, plot(rx_sch(:,1),rx_sch(:,2),"LineWidth",1.7), title("Scenario SCH"), hold on
plot(rx_sch(1,1),rx_sch(1,2),'ro')
for n = 1:size(tgt_sch,1)
    plot(tgt_sch(n,1),tgt_sch(n,2),'^r',LineWidth=1)
end
%TX
plot(tx_sch(1,1),tx_sch(1,2),'*g',LineWidth=1)
%plot(tgt_sch(5,1),tgt_sch(5,2),'^k',LineWidth=1)
hold off
axis equal
% %% Rectify trajectory
% rect_s = linspace(rx_sch(1,1),rx_sch(end,1),size(rx_sch,1));
% rect_c = linspace(rx_sch(1,2),rx_sch(end,2),size(rx_sch,1));
% rect_h = linspace(rx_sch(1,3),rx_sch(end,3),size(rx_sch,1));
% rx_sch = [rect_s(:),rect_c(:),rect_h(:)];
%%
%save("data","Drc","tau_ax","t_ax","radar_parameters","POSE","lla0","targets","tx_enu","rx_enu","yaw","enu2sch","center_enu","rx_sch","tx_sch","rx_speed","tgt_sch");
%% Focusing
% Azimuth resolution (-1 means same as range resolution). set the desiderd azimuth
% resolution
rho_az = .5;
if rho_az == -1
    rho_az = radar_parameters.rho_rg;
end
% Squint for the focusing (deg).
squint = -30:5:30;
superSamp = 4;

% Define the backprojection grid
x_ax = -100:rho_az/superSamp:100;
y_ax = 0+1*(0 : rho_az/superSamp : 150);
[X,Y] = meshgrid(x_ax,y_ax);
Z = zeros(size(X));

if strcmp(exp_name,"exp1")
    Nbegin = floor(34000/USF);%exp1
    Nend = floor(96000/USF);
elseif strcmp(exp_name,"exp9")
    Nbegin = floor(34755/USF);%exp9
    Nend = floor(71500/USF);
elseif strcmp(exp_name,"exp5_mono")
    Nbegin = 1;%exp9
    Nend = floor(44730/USF);
elseif strcmp(exp_name,"exp1_old")
    % Nbegin = 1498/USF;
    % Nend = floor(32000/USF);
    Nbegin = floor(43400/USF);
    Nend = floor(83678/USF);
elseif strcmp(exp_name,"exp3_old")
    Nbegin = floor(9331/USF);
    Nend = floor(45941/USF);
elseif strcmp(exp_name,"exp4_old")
    Nbegin = 1;
    Nend = floor(41300/USF);
end
[stack,sumCount] = focusingCUDA(Drc_ofdm(:,Nbegin:Nend), t_ax, radar_parameters.f0, tx_sch(Nbegin:Nend,:), ...
    rx_sch(Nbegin:Nend,:),rx_speed(Nbegin:Nend), X,Y,Z, rho_az, squint);
%I = focusDroneTDBP(Drc_lp(:,Nbegin:Nend), t_ax, radar_parameters.f0,...
%    traj.Sx(Nbegin:Nend), traj.Sy(Nbegin:Nend), traj.Sz(Nbegin:Nend),...
%    X,Y,Z,...
%    rho_az, squint);
%% Plot
squintIdx = 2;
I = abs(stack(:,:,squintIdx));

cax = [100 160];
figure,printFocused(hamming2DFilter(I,3), x_ax, y_ax, rx_sch(Nbegin:Nend,:),tx_sch(Nbegin:Nend,:),tgt_sch, cax,"Focused image with hamming")
figure,printFocused(I, x_ax, y_ax, rx_sch(Nbegin:Nend,:),tx_sch(Nbegin:Nend,:),tgt_sch, cax,"Focused image")

%% GIF
makeGIF(stack, squint, x_ax, y_ax, rx_sch(Nbegin:Nend,:),tx_sch(Nbegin:Nend,:),tgt_sch, [80 150])
%% Multi look

multiLook = sum(abs(stack),3)./size(stack,3);

I = multiLook;
cax = [120 150];
figure,printFocused(I, x_ax, y_ax, rx_sch(Nbegin:Nend,:),tx_sch(Nbegin:Nend,:),tgt_sch, cax, "Multi look")
%% Georeference grid

geoX = zeros(size(X));
geoY = zeros(size(X));

for i = 1:size(X)
    for j = 1:size(X,2)
        pos = [X(i,j) Y(i,j) 0];
        geoENU = pos * enu2sch' + center_enu;
        posLLA = enu2lla(geoENU,lla0,"flat");
        geoX(i,j) = posLLA(2);
        geoY(i,j) = posLLA(1);
    end
end
%%

%% Prepare output colors range
cax = [120 150];
%outC = db(hamming2DFilter(multiLook,3));
outC = db(multiLook);
outC = outC - cax(1);
outC(outC < 0) = 0;
outC(outC > diff(cax)) = diff(cax);
outC = outC ./ diff(cax);
outC = outC .* 255;
figure,imagesc(x_ax,y_ax,outC),axis xy equal tight,colormap jet,
%%


% [m,n] = size(geoX);            % original size
% [gm,gn] = size(Glat);           % result size
% [X_,Y_] = meshgrid(1:n,1:m);      % original mesh

lonLim = [min(min(geoX)) max(max(geoX))];
latLim = [min(min(geoY)) max(max(geoY))];
pixD = 1000;

lon_ax = linspace(lonLim(1),lonLim(2),pixD);
lat_ax = linspace(latLim(1),latLim(2),pixD);
[Longitude, Latitude ]= meshgrid(lon_ax,lat_ax);

result = griddata(geoX,geoY,double(outC),Longitude,Latitude);


dl_lat = diff(latLim)./size(result,1);
dl_lon = diff(lonLim)./size(result,2);
R = georefcells(latLim, lonLim, dl_lat, dl_lon);
geotiffwrite("test.tif", result, R);